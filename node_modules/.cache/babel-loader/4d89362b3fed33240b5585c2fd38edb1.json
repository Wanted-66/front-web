{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { supportRef } from \"rc-util/es/ref\";\nimport * as React from 'react';\n/**\r\n * Create Immutable pair for `makeImmutable` and `responseImmutable`.\r\n */\nexport default function createImmutable() {\n  var ImmutableContext = /*#__PURE__*/React.createContext(null);\n\n  /**\r\n   * Get render update mark by `makeImmutable` root.\r\n   * Do not deps on the return value as render times\r\n   * but only use for `useMemo` or `useCallback` deps.\r\n   */\n  function useImmutableMark() {\n    return React.useContext(ImmutableContext);\n  }\n\n  /**\r\n  * Wrapped Component will be marked as Immutable.\r\n  * When Component parent trigger render,\r\n  * it will notice children component (use with `responseImmutable`) node that parent has updated.\r\n  * @param Component Passed Component\r\n  * @param triggerRender Customize trigger `responseImmutable` children re-render logic. Default will always trigger re-render when this component re-render.\r\n  */\n  function makeImmutable(Component, shouldTriggerRender) {\n    var refAble = supportRef(Component);\n    var ImmutableComponent = function ImmutableComponent(props, ref) {\n      var refProps = refAble ? {\n        ref: ref\n      } : {};\n      var renderTimesRef = React.useRef(0);\n      var prevProps = React.useRef(props);\n\n      // If parent has the context, we do not wrap it\n      var mark = useImmutableMark();\n      if (mark !== null) {\n        return /*#__PURE__*/React.createElement(Component, _extends({}, props, refProps));\n      }\n      if (\n      // Always trigger re-render if not provide `notTriggerRender`\n      !shouldTriggerRender || shouldTriggerRender(prevProps.current, props)) {\n        renderTimesRef.current += 1;\n      }\n      prevProps.current = props;\n      return /*#__PURE__*/React.createElement(ImmutableContext.Provider, {\n        value: renderTimesRef.current\n      }, /*#__PURE__*/React.createElement(Component, _extends({}, props, refProps)));\n    };\n    if (process.env.NODE_ENV !== 'production') {\n      ImmutableComponent.displayName = \"ImmutableRoot(\".concat(Component.displayName || Component.name, \")\");\n    }\n    return refAble ? /*#__PURE__*/React.forwardRef(ImmutableComponent) : ImmutableComponent;\n  }\n\n  /**\r\n   * Wrapped Component with `React.memo`.\r\n   * But will rerender when parent with `makeImmutable` rerender.\r\n   */\n  function responseImmutable(Component, propsAreEqual) {\n    var refAble = supportRef(Component);\n    var ImmutableComponent = function ImmutableComponent(props, ref) {\n      var refProps = refAble ? {\n        ref: ref\n      } : {};\n      useImmutableMark();\n      return /*#__PURE__*/React.createElement(Component, _extends({}, props, refProps));\n    };\n    if (process.env.NODE_ENV !== 'production') {\n      ImmutableComponent.displayName = \"ImmutableResponse(\".concat(Component.displayName || Component.name, \")\");\n    }\n    return refAble ? /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(ImmutableComponent), propsAreEqual) : /*#__PURE__*/React.memo(ImmutableComponent, propsAreEqual);\n  }\n  return {\n    makeImmutable: makeImmutable,\n    responseImmutable: responseImmutable,\n    useImmutableMark: useImmutableMark\n  };\n}","map":null,"metadata":{},"sourceType":"module"}